### Algorithmic Challenges

91.	Bubble Sort

•	Implement bubble sort to sort a list of integers.

92.	Insertion Sort

•	Implement insertion sort to sort a list of integers.

93.	Selection Sort

•	Implement selection sort to sort a list of integers.

94.	Merge Sort

•	Implement merge sort to sort a list of integers.

95.	Quick Sort

•	Implement quick sort to sort a list of integers.

96.	Binary Search

•	Implement binary search on a sorted list to find a given element.

97.	Linear Search

•	Implement linear search to find an element in a list.

98.	Knuth Shuffle (Fisher–Yates Shuffle)

•	Given a list, shuffle its elements in place uniformly.

99.	Matrix Addition

•	Prompt the user for two matrices (2D lists) of the same dimensions and compute their sum.

100.	Matrix Multiplication

•	Prompt the user for two matrices and multiply them if their dimensions are compatible.

101.	Transposition of a Matrix

•	Compute the transpose of a user-provided matrix.

102.	Check if a Matrix is Symmetric

•	Determine if a given square matrix is symmetric (equal to its transpose).

103.	Longest Common Substring

•	Find the longest common substring between two given strings.

104.	Longest Common Subsequence (LCS)

•	Implement the LCS algorithm for two sequences.

105.	Coin Change (Greedy)

•	Given a list of coin denominations and a target amount, find the minimum number of coins needed using a greedy approach.

106.	Coin Change (DP)

•	Solve the coin change problem using dynamic programming for an exact solution.

107.	Knapsack Problem (0/1 DP)

•	Implement the 0/1 Knapsack using dynamic programming.

108.	Permutations of a List

•	Generate all permutations of a given list of distinct elements.

109.	Backtracking: N-Queens

•	Implement the N-Queens puzzle using backtracking.

110.	Shortest Path in a Grid

•	Given a 2D grid, find the shortest path from top-left to bottom-right, moving only down or right (use BFS or DFS).